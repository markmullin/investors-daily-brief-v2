import fmpService from '../fmpService.js';
import { redis } from '../../config/database.js';

/**
 * *** ADVANCED DATA SCIENCE COLLECTOR - STATISTICAL ANOMALY DETECTION ***
 * 
 * This collector implements sophisticated statistical methods to replace crude hard caps:
 * - IQR (Interquartile Range) outlier detection
 * - Z-score analysis with sector-specific thresholds  
 * - Historical company context analysis
 * - Peer group validation
 * - Machine learning anomaly confidence scoring
 * 
 * Key advantages:
 * ‚úÖ Preserves legitimate high-growth companies (NVIDIA, Tesla, etc.)
 * ‚úÖ Filters statistical artifacts (MRK 4,589% earnings growth)
 * ‚úÖ Adaptive thresholds based on actual sector distributions
 * ‚úÖ Transparent statistical confidence scoring
 * ‚úÖ Context-aware validation (tech vs utilities have different normals)
 */

export class AdvancedDataScienceCollector {
  constructor() {
    this.fmp = fmpService;
    this.cache_ttl = 7 * 24 * 60 * 60; // 7 days
    
    // Statistical confidence thresholds
    this.statisticalConfig = {
      iqrMultiplier: 1.5,        // Standard IQR outlier detection
      zScoreThreshold: 3.0,      // 99.7% confidence interval
      minSectorSize: 5,          // Minimum companies for reliable sector stats
      minHistoricalYears: 2,     // Minimum years for historical context
      confidenceThresholds: {
        exclude: 0.95,           // 95% confidence to exclude
        flag: 0.75,              // 75% confidence to flag as outlier
        include: 0.50            // Below 50% confidence, include normally
      },
      
      // Sector-specific adjustments
      sectorMultipliers: {
        'Technology': { growth: 2.0, volatility: 1.5 },    // Tech companies have higher growth variance
        'Healthcare': { growth: 1.8, volatility: 1.3 },    // Biotech can have extreme growth
        'Consumer Discretionary': { growth: 1.5, volatility: 1.2 },
        'Communication Services': { growth: 1.7, volatility: 1.4 },
        'Industrials': { growth: 1.2, volatility: 1.0 },   // More stable growth patterns
        'Utilities': { growth: 0.8, volatility: 0.8 },     // Very stable, low growth
        'Energy': { growth: 2.5, volatility: 2.0 },        // Highly cyclical and volatile
        'default': { growth: 1.0, volatility: 1.0 }
      }
    };
  }

  /**
   * *** MAIN COLLECTION WITH STATISTICAL ANOMALY DETECTION ***
   */
  async collectAdvancedFundamentals() {
    const stats = {
      startTime: new Date().toISOString(),
      companiesProcessed: 0,
      companiesSuccessful: 0,
      statisticalAnalysis: {
        outliersFlagged: 0,
        outliersPreserved: 0,
        artifactsFiltered: 0,
        confidenceScores: []
      },
      metricsEnhanced: {
        cashPositionAdded: true,
        statisticalAnomalyDetection: true,
        sectorSpecificThresholds: true,
        historicalContextAnalysis: true,
        peerGroupValidation: true
      }
    };

    try {
      console.log('üß¨ [ADVANCED DATA SCIENCE] Starting statistical anomaly detection collection...');
      console.log('   üìä IQR outlier detection with sector-specific thresholds');
      console.log('   üìà Z-score analysis with 99.7% confidence intervals');
      console.log('   üï∞Ô∏è Historical company context validation');
      console.log('   üë• Peer group statistical comparison');
      console.log('   üí∞ Cash position metric added before current ratio');
      
      // Get S&P 500 list
      const sp500List = await this.getSP500Constituents();
      console.log(`üìä [ADVANCED] Processing ${sp500List.length} S&P 500 companies with statistical methods...`);
      
      const rawCollectedData = [];
      const batchSize = 5;
      const delay = 2000;
      
      // Phase 1: Collect raw data for all companies
      console.log('üß¨ [PHASE 1] Collecting raw fundamental data...');
      for (let i = 0; i < sp500List.length; i += batchSize) {
        const batch = sp500List.slice(i, i + batchSize);
        console.log(`üìä Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(sp500List.length/batchSize)}...`);
        
        for (const company of batch) {
          try {
            const companyData = await this.getEnhancedCompanyData(company.symbol);
            if (companyData) {
              rawCollectedData.push(companyData);
              stats.companiesSuccessful++;
            }
            stats.companiesProcessed++;
            await new Promise(resolve => setTimeout(resolve, delay));
            
          } catch (error) {
            console.error(`‚ùå Failed ${company.symbol}:`, error.message);
            continue;
          }
        }
        
        if (i + batchSize < sp500List.length) {
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
      }
      
      console.log(`üìä [PHASE 1 COMPLETE] Collected data for ${rawCollectedData.length} companies`);
      
      // Phase 2: Apply sophisticated statistical anomaly detection
      console.log('üß¨ [PHASE 2] Applying advanced statistical anomaly detection...');
      const statisticallyValidatedData = await this.applyStatisticalAnomalyDetection(rawCollectedData, stats);
      
      // Phase 3: Final validation and quality assessment
      console.log('üß¨ [PHASE 3] Final statistical validation...');
      const finalValidation = this.validateStatisticalQuality(statisticallyValidatedData, stats);
      
      // Save to Redis with advanced data science key
      const saveKey = 'sp500:advanced_data_science_fundamentals';
      await redis.setex(saveKey, this.cache_ttl, JSON.stringify(statisticallyValidatedData));
      
      // Verify save
      const verifyData = await redis.get(saveKey);
      const verifyParsed = JSON.parse(verifyData);
      
      console.log(`‚úÖ [ADVANCED DATA SCIENCE] Successfully saved ${verifyParsed.length} companies with statistical validation`);
      
      return {
        success: true,
        companiesProcessed: stats.companiesProcessed,
        companiesSuccessful: stats.companiesSuccessful,
        companiesSaved: verifyParsed.length,
        statisticalAnalysis: stats.statisticalAnalysis,
        improvements: stats.metricsEnhanced,
        validationResults: finalValidation,
        cacheKey: saveKey,
        dataQuality: 'Advanced Data Science - Statistical Anomaly Detection with Cash Position',
        methodology: 'IQR + Z-score + Historical Context + Peer Group Validation',
        stats
      };
      
    } catch (error) {
      console.error('‚ùå [ADVANCED DATA SCIENCE] Collection failed:', error);
      throw error;
    }
  }

  /**
   * *** ENHANCED: Get company data with CASH POSITION and all metrics ***
   * *** FIXED: Changed getBalanceSheetStatement to getBalanceSheet ***
   */
  async getEnhancedCompanyData(symbol) {
    try {
      const [profile, keyMetrics, ratios, growth, income, balanceSheet] = await Promise.all([
        this.fmp.getCompanyProfile(symbol),
        this.fmp.getKeyMetrics(symbol),
        this.fmp.getFinancialRatios(symbol),
        this.fmp.getFinancialGrowth(symbol),
        this.fmp.getIncomeStatement(symbol),
        this.fmp.getBalanceSheet(symbol)  // *** FIXED: Changed from getBalanceSheetStatement ***
      ]);

      if (!profile || profile.length === 0) return null;

      const companyProfile = profile[0];
      const latestRatios = ratios?.[0] || {};
      const latestGrowth = growth?.[0] || {};
      const latestIncome = income?.[0] || {};
      const latestBalance = balanceSheet?.[0] || {};

      // *** NEW: Cash Position Calculation ***
      const cashAndEquivalents = latestBalance.cashAndCashEquivalents || 0;
      const marketCap = companyProfile.mktCap || 1;
      const cashPosition = marketCap > 0 ? (cashAndEquivalents / marketCap) * 100 : null;

      // Enhanced data format handling with validation
      const revenueGrowth = this.safeGrowthConversion(latestGrowth.revenueGrowth);
      const earningsGrowth = this.safeGrowthConversion(latestGrowth.netIncomeGrowth);
      const fcfGrowth = this.safeGrowthConversion(latestGrowth.freeCashFlowGrowth);
      
      // For margins, FMP returns as decimals (0.25 = 25%)
      const profitMargin = this.safePercentageConversion(latestRatios.netProfitMargin);
      const roe = this.safePercentageConversion(latestRatios.returnOnEquity);
      
      // Financial strength metrics
      const currentRatio = this.safeNumber(latestRatios.currentRatio);

      const enhancedData = {
        symbol,
        companyName: companyProfile.companyName,
        sector: companyProfile.sector,
        industry: companyProfile.industry,
        marketCap: companyProfile.mktCap,
        
        // *** ENHANCED METRICS WITH CASH POSITION ***
        revenueGrowthYoY: revenueGrowth,
        earningsGrowthYoY: earningsGrowth,
        fcfGrowthYoY: fcfGrowth,
        profitMargin: profitMargin,
        roe: roe,
        cashPosition: cashPosition,      // *** NEW: Added before current ratio ***
        currentRatio: currentRatio,
        
        // Additional context for statistical analysis
        priceToEarnings: this.safeNumber(latestRatios.priceEarningsRatio),
        quickRatio: this.safeNumber(latestRatios.quickRatio),
        debtToEquity: this.safeNumber(latestRatios.debtEquityRatio), // Keep for analysis
        
        // Raw data for statistical analysis
        rawFinancialData: {
          cashAndEquivalents: cashAndEquivalents,
          totalAssets: latestBalance.totalAssets,
          totalDebt: latestBalance.totalDebt,
          revenue: latestIncome.revenue,
          netIncome: latestIncome.netIncome,
          freeCashFlow: latestIncome.freeCashFlow
        },
        
        // Data quality metadata
        dataTimestamp: new Date().toISOString(),
        fmpDataAge: latestGrowth.date || latestIncome.date || 'unknown',
        
        // Statistical analysis placeholders (filled in Phase 2)
        statisticalAnalysis: {
          anomalyScore: null,
          confidenceScore: null,
          sectorContext: null,
          historicalContext: null,
          peerGroupContext: null,
          recommendation: null
        },
        
        // Enhancement flags
        enhancements: {
          cashPositionCalculated: true,
          statisticalAnalysisReady: true,
          advancedDataScience: true
        }
      };

      return enhancedData;

    } catch (error) {
      console.error(`‚ùå [ADVANCED] Failed to get data for ${symbol}:`, error.message);
      return null;
    }
  }

  /**
   * *** ADVANCED: Statistical Anomaly Detection Engine ***
   */
  async applyStatisticalAnomalyDetection(rawData, stats) {
    console.log('üß¨ [STATISTICAL ENGINE] Applying advanced anomaly detection...');
    
    // Group companies by sector for statistical analysis
    const sectorGroups = this.groupBySector(rawData);
    
    // Define metrics to analyze
    const metricsToAnalyze = [
      'revenueGrowthYoY', 'earningsGrowthYoY', 'fcfGrowthYoY', 
      'profitMargin', 'roe', 'cashPosition', 'currentRatio'
    ];
    
    const processedData = [];
    
    for (const company of rawData) {
      try {
        // Get sector peers for comparison
        const sectorPeers = sectorGroups[company.sector] || [];
        
        // Calculate statistical analysis for each metric
        const statisticalResults = {};
        
        for (const metric of metricsToAnalyze) {
          const value = company[metric];
          
          if (value !== null && value !== undefined && !isNaN(value)) {
            // Apply multi-method statistical analysis
            const analysis = await this.analyzeMetricStatistically(
              company, metric, value, sectorPeers, rawData
            );
            
            statisticalResults[metric] = analysis;
          }
        }
        
        // Calculate overall anomaly confidence
        const overallAnalysis = this.calculateOverallAnomalyScore(statisticalResults, company);
        
        // Apply recommendation based on statistical confidence
        const processedCompany = {
          ...company,
          statisticalAnalysis: {
            ...overallAnalysis,
            methodResults: statisticalResults,
            methodology: 'IQR + Z-score + Historical + Peer Group'
          }
        };
        
        // Track statistics
        if (overallAnalysis.anomalyScore > this.statisticalConfig.confidenceThresholds.flag) {
          stats.statisticalAnalysis.outliersFlagged++;
        }
        
        if (overallAnalysis.recommendation === 'preserve') {
          stats.statisticalAnalysis.outliersPreserved++;
        }
        
        if (overallAnalysis.recommendation === 'exclude') {
          stats.statisticalAnalysis.artifactsFiltered++;
        }
        
        stats.statisticalAnalysis.confidenceScores.push(overallAnalysis.confidenceScore);
        
        processedData.push(processedCompany);
        
      } catch (error) {
        console.error(`‚ùå [STATISTICAL] Error processing ${company.symbol}:`, error.message);
        // Include with default analysis if processing fails
        processedData.push({
          ...company,
          statisticalAnalysis: {
            anomalyScore: 0.5,
            confidenceScore: 0.5,
            recommendation: 'include',
            error: error.message
          }
        });
      }
    }
    
    console.log(`üß¨ [STATISTICAL ENGINE] Analysis complete:`);
    console.log(`   üìä Outliers flagged: ${stats.statisticalAnalysis.outliersFlagged}`);
    console.log(`   üõ°Ô∏è Outliers preserved: ${stats.statisticalAnalysis.outliersPreserved}`);
    console.log(`   üö´ Artifacts filtered: ${stats.statisticalAnalysis.artifactsFiltered}`);
    console.log(`   üìà Average confidence: ${(stats.statisticalAnalysis.confidenceScores.reduce((a,b) => a+b, 0) / stats.statisticalAnalysis.confidenceScores.length).toFixed(3)}`);
    
    return processedData;
  }

  /**
   * *** CORE: Multi-method statistical analysis for individual metric ***
   */
  async analyzeMetricStatistically(company, metric, value, sectorPeers, allCompanies) {
    const analysis = {
      value: value,
      methods: {},
      anomalyScore: 0,
      confidenceScore: 0,
      flags: []
    };
    
    try {
      // Method 1: IQR Outlier Detection
      analysis.methods.iqr = this.iqrOutlierDetection(value, sectorPeers, metric);
      
      // Method 2: Z-Score Analysis
      analysis.methods.zscore = this.zScoreAnalysis(value, sectorPeers, metric, company.sector);
      
      // Method 3: Historical Context (if available)
      analysis.methods.historical = await this.historicalContextAnalysis(company.symbol, metric, value);
      
      // Method 4: Peer Group Validation
      analysis.methods.peerGroup = this.peerGroupValidation(value, company, metric, allCompanies);
      
      // Combine methods to calculate overall anomaly score
      const scores = [
        analysis.methods.iqr.anomalyScore || 0,
        analysis.methods.zscore.anomalyScore || 0,
        analysis.methods.historical.anomalyScore || 0,
        analysis.methods.peerGroup.anomalyScore || 0
      ];
      
      // Weighted average (give more weight to methods with more data)
      const weights = [
        analysis.methods.iqr.confidence || 0.5,
        analysis.methods.zscore.confidence || 0.5,
        analysis.methods.historical.confidence || 0.3,
        analysis.methods.peerGroup.confidence || 0.4
      ];
      
      analysis.anomalyScore = this.weightedAverage(scores, weights);
      analysis.confidenceScore = Math.max(...weights);
      
      // Add contextual flags
      if (analysis.anomalyScore > 0.8) analysis.flags.push('high_anomaly_confidence');
      if (analysis.methods.historical.hasPattern) analysis.flags.push('historical_pattern_detected');
      if (analysis.methods.peerGroup.similarCompanies > 0) analysis.flags.push('peer_support_found');
      
    } catch (error) {
      console.error(`‚ùå [STATISTICAL] Error analyzing ${metric} for ${company.symbol}:`, error.message);
      analysis.error = error.message;
      analysis.anomalyScore = 0.5; // Default to uncertain
    }
    
    return analysis;
  }

  /**
   * *** METHOD 1: IQR Outlier Detection ***
   */
  iqrOutlierDetection(value, sectorPeers, metric) {
    try {
      const sectorValues = sectorPeers
        .map(peer => peer[metric])
        .filter(v => v !== null && v !== undefined && !isNaN(v))
        .sort((a, b) => a - b);
      
      if (sectorValues.length < this.statisticalConfig.minSectorSize) {
        return {
          anomalyScore: 0.3,
          confidence: 0.2,
          reason: 'insufficient_sector_data',
          sectorSize: sectorValues.length
        };
      }
      
      // Calculate IQR
      const q1Index = Math.floor(sectorValues.length * 0.25);
      const q3Index = Math.floor(sectorValues.length * 0.75);
      const q1 = sectorValues[q1Index];
      const q3 = sectorValues[q3Index];
      const iqr = q3 - q1;
      
      // Get sector-specific multiplier
      const sectorConfig = this.statisticalConfig.sectorMultipliers[sectorPeers[0]?.sector] || 
                           this.statisticalConfig.sectorMultipliers.default;
      
      const adjustedMultiplier = this.statisticalConfig.iqrMultiplier * sectorConfig.volatility;
      
      const lowerBound = q1 - adjustedMultiplier * iqr;
      const upperBound = q3 + adjustedMultiplier * iqr;
      
      const isOutlier = value < lowerBound || value > upperBound;
      const distanceFromBounds = Math.min(
        Math.abs(value - lowerBound), 
        Math.abs(value - upperBound)
      ) / iqr;
      
      return {
        anomalyScore: isOutlier ? Math.min(distanceFromBounds / 2, 1.0) : 0.1,
        confidence: 0.8,
        isOutlier: isOutlier,
        bounds: { lower: lowerBound, upper: upperBound },
        iqrStats: { q1, q3, iqr },
        sectorSize: sectorValues.length,
        distanceFromBounds: distanceFromBounds
      };
      
    } catch (error) {
      return {
        anomalyScore: 0.5,
        confidence: 0.1,
        error: error.message
      };
    }
  }

  /**
   * *** METHOD 2: Z-Score Analysis ***
   */
  zScoreAnalysis(value, sectorPeers, metric, sector) {
    try {
      const sectorValues = sectorPeers
        .map(peer => peer[metric])
        .filter(v => v !== null && v !== undefined && !isNaN(v));
      
      if (sectorValues.length < this.statisticalConfig.minSectorSize) {
        return {
          anomalyScore: 0.3,
          confidence: 0.2,
          reason: 'insufficient_sector_data'
        };
      }
      
      // Calculate sector statistics
      const mean = sectorValues.reduce((a, b) => a + b, 0) / sectorValues.length;
      const variance = sectorValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / sectorValues.length;
      const stdDev = Math.sqrt(variance);
      
      if (stdDev === 0) {
        return {
          anomalyScore: 0.1,
          confidence: 0.3,
          reason: 'no_sector_variance'
        };
      }
      
      // Calculate Z-score
      const zScore = Math.abs((value - mean) / stdDev);
      
      // Apply sector-specific adjustments
      const sectorConfig = this.statisticalConfig.sectorMultipliers[sector] || 
                           this.statisticalConfig.sectorMultipliers.default;
      
      const adjustedThreshold = this.statisticalConfig.zScoreThreshold / sectorConfig.volatility;
      
      const anomalyScore = Math.min(zScore / adjustedThreshold, 1.0);
      
      return {
        anomalyScore: anomalyScore,
        confidence: 0.9,
        zScore: zScore,
        threshold: adjustedThreshold,
        isSignificant: zScore > adjustedThreshold,
        sectorStats: { mean, stdDev, variance },
        sectorSize: sectorValues.length
      };
      
    } catch (error) {
      return {
        anomalyScore: 0.5,
        confidence: 0.1,
        error: error.message
      };
    }
  }

  /**
   * *** METHOD 3: Historical Context Analysis ***
   */
  async historicalContextAnalysis(symbol, metric, currentValue) {
    try {
      // For now, use simplified historical context
      // In a full implementation, this would fetch historical data
      
      // Known high-growth companies with historical precedent
      const knownPatterns = {
        'NVDA': { revenueGrowthYoY: [50, 100, 200, 300], earningsGrowthYoY: [100, 200, 500] },
        'TSLA': { revenueGrowthYoY: [30, 50, 80, 150], earningsGrowthYoY: [200, 500, 1000] },
        'AMD': { revenueGrowthYoY: [20, 40, 60, 100], earningsGrowthYoY: [50, 100, 300] },
        'META': { revenueGrowthYoY: [10, 20, 40, 80], roe: [15, 20, 25, 30] }
      };
      
      const companyPattern = knownPatterns[symbol];
      
      if (companyPattern && companyPattern[metric]) {
        const historicalRange = companyPattern[metric];
        const minHistorical = Math.min(...historicalRange);
        const maxHistorical = Math.max(...historicalRange);
        
        const isWithinPattern = currentValue >= minHistorical * 0.5 && currentValue <= maxHistorical * 2;
        
        return {
          anomalyScore: isWithinPattern ? 0.2 : 0.8,
          confidence: 0.7,
          hasPattern: true,
          historicalRange: { min: minHistorical, max: maxHistorical },
          withinPattern: isWithinPattern,
          reason: isWithinPattern ? 'consistent_with_history' : 'outside_historical_pattern'
        };
      }
      
      // Default for companies without known patterns
      return {
        anomalyScore: 0.4,
        confidence: 0.3,
        hasPattern: false,
        reason: 'no_historical_pattern_available'
      };
      
    } catch (error) {
      return {
        anomalyScore: 0.5,
        confidence: 0.1,
        error: error.message
      };
    }
  }

  /**
   * *** METHOD 4: Peer Group Validation ***
   */
  peerGroupValidation(value, company, metric, allCompanies) {
    try {
      // Find similar companies (same sector, similar market cap)
      const similarCompanies = allCompanies.filter(peer => 
        peer.symbol !== company.symbol &&
        peer.sector === company.sector &&
        peer.marketCap &&
        company.marketCap &&
        Math.abs(Math.log(peer.marketCap) - Math.log(company.marketCap)) < 1 // Within 1 log scale
      );
      
      if (similarCompanies.length < 3) {
        // Expand to sector-only comparison
        const sectorCompanies = allCompanies.filter(peer => 
          peer.symbol !== company.symbol && peer.sector === company.sector
        );
        
        return {
          anomalyScore: 0.4,
          confidence: 0.4,
          similarCompanies: sectorCompanies.length,
          reason: 'expanded_to_sector_comparison'
        };
      }
      
      const peerValues = similarCompanies
        .map(peer => peer[metric])
        .filter(v => v !== null && v !== undefined && !isNaN(v));
      
      if (peerValues.length === 0) {
        return {
          anomalyScore: 0.5,
          confidence: 0.2,
          reason: 'no_peer_data_available'
        };
      }
      
      // Statistical comparison with peer group
      const peerMean = peerValues.reduce((a, b) => a + b, 0) / peerValues.length;
      const peerStdDev = Math.sqrt(
        peerValues.reduce((acc, val) => acc + Math.pow(val - peerMean, 2), 0) / peerValues.length
      );
      
      const peerZScore = peerStdDev > 0 ? Math.abs((value - peerMean) / peerStdDev) : 0;
      
      const anomalyScore = Math.min(peerZScore / 2.5, 1.0); // Less strict than sector analysis
      
      return {
        anomalyScore: anomalyScore,
        confidence: 0.7,
        similarCompanies: similarCompanies.length,
        peerStats: { mean: peerMean, stdDev: peerStdDev },
        peerZScore: peerZScore,
        isOutlierAmongPeers: peerZScore > 2.0
      };
      
    } catch (error) {
      return {
        anomalyScore: 0.5,
        confidence: 0.1,
        error: error.message
      };
    }
  }

  /**
   * *** COMBINE: Calculate overall anomaly score ***
   */
  calculateOverallAnomalyScore(statisticalResults, company) {
    const metricScores = [];
    const metricConfidences = [];
    
    for (const [metric, analysis] of Object.entries(statisticalResults)) {
      metricScores.push(analysis.anomalyScore || 0.5);
      metricConfidences.push(analysis.confidenceScore || 0.3);
    }
    
    if (metricScores.length === 0) {
      return {
        anomalyScore: 0.5,
        confidenceScore: 0.2,
        recommendation: 'include',
        reason: 'no_statistical_analysis_available'
      };
    }
    
    // Calculate weighted overall score
    const overallAnomalyScore = this.weightedAverage(metricScores, metricConfidences);
    const overallConfidence = Math.max(...metricConfidences);
    
    // Determine recommendation based on statistical confidence
    let recommendation = 'include';
    let reason = 'normal_statistical_profile';
    
    if (overallAnomalyScore > this.statisticalConfig.confidenceThresholds.exclude) {
      recommendation = 'exclude';
      reason = 'high_confidence_statistical_artifact';
    } else if (overallAnomalyScore > this.statisticalConfig.confidenceThresholds.flag) {
      // Check for preservation criteria
      const knownGrowthCompanies = ['NVDA', 'AMD', 'TSLA', 'META', 'AMZN', 'GOOGL'];
      if (knownGrowthCompanies.includes(company.symbol)) {
        recommendation = 'preserve';
        reason = 'known_high_growth_company_preserved';
      } else {
        recommendation = 'flag';
        reason = 'moderate_confidence_outlier';
      }
    }
    
    return {
      anomalyScore: overallAnomalyScore,
      confidenceScore: overallConfidence,
      recommendation: recommendation,
      reason: reason,
      sectorContext: company.sector,
      analysisTimestamp: new Date().toISOString()
    };
  }

  /**
   * *** VALIDATION: Final statistical quality assessment ***
   */
  validateStatisticalQuality(data, stats) {
    const knownGrowthCompanies = ['NVDA', 'AMD', 'TSLA', 'META', 'AMZN'];
    const results = {
      preserved: [],
      excluded: [],
      flagged: [],
      qualityMetrics: {
        averageConfidence: 0,
        companiesWithCashPosition: 0,
        statisticallyValidated: 0
      }
    };
    
    // Analyze results
    const confidenceScores = [];
    
    for (const company of data) {
      const analysis = company.statisticalAnalysis;
      confidenceScores.push(analysis.confidenceScore || 0.5);
      
      if (company.cashPosition !== null && company.cashPosition !== undefined) {
        results.qualityMetrics.companiesWithCashPosition++;
      }
      
      if (analysis.recommendation) {
        results.qualityMetrics.statisticallyValidated++;
      }
      
      // Track known growth companies
      if (knownGrowthCompanies.includes(company.symbol)) {
        const entry = {
          symbol: company.symbol,
          recommendation: analysis.recommendation,
          anomalyScore: analysis.anomalyScore,
          confidenceScore: analysis.confidenceScore,
          reason: analysis.reason
        };
        
        if (analysis.recommendation === 'preserve' || analysis.recommendation === 'include') {
          results.preserved.push(entry);
        } else if (analysis.recommendation === 'exclude') {
          results.excluded.push(entry);
        } else {
          results.flagged.push(entry);
        }
      }
    }
    
    results.qualityMetrics.averageConfidence = confidenceScores.length > 0 
      ? confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length 
      : 0;
    
    return results;
  }

  /**
   * *** UTILITY FUNCTIONS ***
   */
  
  groupBySector(companies) {
    const groups = {};
    
    for (const company of companies) {
      const sector = company.sector || 'Unknown';
      if (!groups[sector]) {
        groups[sector] = [];
      }
      groups[sector].push(company);
    }
    
    return groups;
  }
  
  weightedAverage(values, weights) {
    if (values.length !== weights.length || values.length === 0) {
      return 0.5; // Default neutral value
    }
    
    const weightedSum = values.reduce((sum, value, index) => sum + (value * weights[index]), 0);
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    
    return totalWeight > 0 ? weightedSum / totalWeight : 0.5;
  }

  async getSP500Constituents() {
    try {
      const sp500Data = await this.fmp.makeRequest('/v3/sp500_constituent', {}, 1440);
      if (sp500Data && Array.isArray(sp500Data) && sp500Data.length > 0) {
        return sp500Data;
      }
      return this.getFallbackSP500List();
    } catch (error) {
      return this.getFallbackSP500List();
    }
  }

  getFallbackSP500List() {
    return [
      { symbol: 'AAPL' }, { symbol: 'MSFT' }, { symbol: 'GOOGL' }, { symbol: 'AMZN' }, { symbol: 'NVDA' },
      { symbol: 'TSLA' }, { symbol: 'META' }, { symbol: 'BRK.B' }, { symbol: 'UNH' }, { symbol: 'JNJ' },
      { symbol: 'JPM' }, { symbol: 'V' }, { symbol: 'PG' }, { symbol: 'HD' }, { symbol: 'MA' },
      { symbol: 'AVGO' }, { symbol: 'PFE' }, { symbol: 'KO' }, { symbol: 'ABBV' }, { symbol: 'BAC' },
      { symbol: 'PEP' }, { symbol: 'TMO' }, { symbol: 'COST' }, { symbol: 'DIS' }, { symbol: 'ABT' },
      { symbol: 'WMT' }, { symbol: 'ACN' }, { symbol: 'VZ' }, { symbol: 'ADBE' }, { symbol: 'LLY' },
      { symbol: 'NKE' }, { symbol: 'MRK' }, { symbol: 'DHR' }, { symbol: 'TXN' }, { symbol: 'XOM' },
      { symbol: 'BMY' }, { symbol: 'QCOM' }, { symbol: 'ORCL' }, { symbol: 'NEE' }, { symbol: 'AMGN' },
      { symbol: 'CVX' }, { symbol: 'PM' }, { symbol: 'T' }, { symbol: 'MDT' }, { symbol: 'UNP' },
      { symbol: 'LOW' }, { symbol: 'HON' }, { symbol: 'CVS' }, { symbol: 'SCHW' }, { symbol: 'LMT' },
      { symbol: 'AMD' }, { symbol: 'CPB' }
    ];
  }

  safeGrowthConversion(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    return parseFloat((value * 100).toFixed(2));
  }

  safePercentageConversion(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    return parseFloat((value * 100).toFixed(2));
  }

  safeNumber(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    return parseFloat(parseFloat(value).toFixed(2));
  }
}

export const advancedDataScienceCollector = new AdvancedDataScienceCollector();