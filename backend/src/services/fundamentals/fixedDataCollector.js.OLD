import fmpService from '../fmpService.js';
import { redis } from '../../config/database.js';

/**
 * *** PRODUCTION-READY DATA COLLECTOR - ENHANCED FOR SATURDAY COLLECTION ***
 * 
 * This service includes all production improvements:
 * - Current Ratio replaces debt-to-equity for better balance sheet analysis
 * - Enhanced anomaly filtering caps extreme outliers (earnings >500%, ROE >300%)
 * - Removed projected metrics (were empty/not working)
 * - Preserves high-growth companies like NVIDIA with proper validation
 * - Production-quality data for Saturday automatic collection
 */

export class FixedDataCollector {
  constructor() {
    this.fmp = fmpService;
    this.cache_ttl = 7 * 24 * 60 * 60; // 7 days
  }

  /**
   * *** PRODUCTION: Enhanced collection with improved metrics and filtering ***
   */
  async collectFixedFundamentals() {
    const stats = {
      startTime: new Date().toISOString(),
      companiesProcessed: 0,
      companiesSuccessful: 0,
      anomaliesFiltered: 0,
      metricsImproved: {
        debtToEquityReplaced: true,
        projectedMetricsRemoved: true,
        anomalyFilteringEnhanced: true
      },
      knownGrowthCompanies: {
        preserved: [],
        missing: []
      }
    };

    try {
      console.log('üöÄ [PRODUCTION] Starting enhanced fundamentals collection...');
      console.log('   ‚úÖ Current Ratio replaces debt-to-equity');
      console.log('   ‚úÖ Enhanced anomaly filtering for extreme outliers');
      console.log('   ‚úÖ Removed projected metrics (empty data)');
      console.log('   ‚úÖ Production-ready for Saturday collection');
      
      // Get S&P 500 list
      const sp500List = await this.getSP500Constituents();
      console.log(`üìä [PRODUCTION] Processing ${sp500List.length} S&P 500 companies...`);
      
      const collectedData = [];
      const batchSize = 5;
      const delay = 2000;
      
      // Known high-growth companies that should be preserved
      const knownGrowthCompanies = ['NVDA', 'AMD', 'TSLA', 'META', 'AMZN', 'GOOGL', 'MSFT', 'AAPL'];
      
      for (let i = 0; i < sp500List.length; i += batchSize) {
        const batch = sp500List.slice(i, i + batchSize);
        console.log(`üöÄ [PRODUCTION] Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(sp500List.length/batchSize)}...`);
        
        for (const company of batch) {
          try {
            const enhancedData = await this.getEnhancedCompanyData(company.symbol);
            if (enhancedData) {
              collectedData.push(enhancedData);
              stats.companiesSuccessful++;
              
              // Track known growth companies
              if (knownGrowthCompanies.includes(company.symbol)) {
                stats.knownGrowthCompanies.preserved.push({
                  symbol: company.symbol,
                  revenueGrowth: enhancedData.revenueGrowthYoY,
                  currentRatio: enhancedData.currentRatio
                });
              }
              
              console.log(`‚úÖ [PRODUCTION] ${company.symbol}: Revenue ${enhancedData.revenueGrowthYoY?.toFixed(1)}%, Current Ratio ${enhancedData.currentRatio?.toFixed(2)}x`);
            }
            
            stats.companiesProcessed++;
            await new Promise(resolve => setTimeout(resolve, delay));
            
          } catch (error) {
            console.error(`‚ùå [PRODUCTION] Failed ${company.symbol}:`, error.message);
            continue;
          }
        }
        
        if (i + batchSize < sp500List.length) {
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
      }
      
      console.log(`üìä [PRODUCTION] Data collection completed: ${collectedData.length} companies`);
      
      // *** ENHANCED: Apply production-quality anomaly filtering ***
      const qualityData = await this.applyProductionQualityFiltering(collectedData, stats);
      
      // *** CRITICAL: Verify known growth companies are preserved ***
      const finalValidation = this.validateProductionQuality(qualityData);
      
      if (finalValidation.criticalIssues.length > 0) {
        console.warn('‚ö†Ô∏è [PRODUCTION] Quality issues detected:');
        finalValidation.criticalIssues.forEach(issue => console.warn(`   - ${issue}`));
      }
      
      // Save to Redis with production key
      const saveKey = 'sp500:fixed_quality_fundamentals';
      const saveResult = await redis.setex(saveKey, this.cache_ttl, JSON.stringify(qualityData));
      
      // Verify save
      const verifyData = await redis.get(saveKey);
      const verifyParsed = JSON.parse(verifyData);
      
      console.log(`‚úÖ [PRODUCTION] Successfully saved ${verifyParsed.length} companies with enhanced quality controls`);
      
      return {
        success: true,
        companiesProcessed: stats.companiesProcessed,
        companiesSuccessful: stats.companiesSuccessful,
        companiesSaved: verifyParsed.length,
        anomaliesFiltered: stats.anomaliesFiltered,
        improvements: stats.metricsImproved,
        knownGrowthCompanies: stats.knownGrowthCompanies,
        validationResults: finalValidation,
        cacheKey: saveKey,
        dataQuality: 'Production Enhanced - Current Ratio, Anomaly Filtering, High-Growth Preserved',
        stats
      };
      
    } catch (error) {
      console.error('‚ùå [PRODUCTION] Collection failed:', error);
      throw error;
    }
  }

  /**
   * *** ENHANCED: Get company data with current ratio and improved metrics ***
   */
  async getEnhancedCompanyData(symbol) {
    try {
      const [profile, keyMetrics, ratios, growth, income] = await Promise.all([
        this.fmp.getCompanyProfile(symbol),
        this.fmp.getKeyMetrics(symbol),
        this.fmp.getFinancialRatios(symbol),
        this.fmp.getFinancialGrowth(symbol),
        this.fmp.getIncomeStatement(symbol)
      ]);

      if (!profile || profile.length === 0) return null;

      const companyProfile = profile[0];
      const latestRatios = ratios?.[0] || {};
      const latestGrowth = growth?.[0] || {};
      const latestIncome = income?.[0] || {};

      // *** ENHANCED: Careful data format handling with validation ***
      const revenueGrowth = this.safeGrowthConversion(latestGrowth.revenueGrowth);
      const earningsGrowth = this.safeGrowthConversion(latestGrowth.netIncomeGrowth);
      const fcfGrowth = this.safeGrowthConversion(latestGrowth.freeCashFlowGrowth);
      
      // For margins, FMP returns as decimals (0.25 = 25%)
      const profitMargin = this.safePercentageConversion(latestRatios.netProfitMargin);
      const roe = this.safePercentageConversion(latestRatios.returnOnEquity);
      
      // *** NEW: Current Ratio instead of debt-to-equity ***
      const currentRatio = this.safeNumber(latestRatios.currentRatio);

      const enhancedData = {
        symbol,
        companyName: companyProfile.companyName,
        sector: companyProfile.sector,
        industry: companyProfile.industry,
        marketCap: companyProfile.mktCap,
        
        // *** PRODUCTION METRICS - ENHANCED ***
        revenueGrowthYoY: revenueGrowth,
        earningsGrowthYoY: earningsGrowth,
        fcfGrowthYoY: fcfGrowth,
        profitMargin: profitMargin,
        roe: roe,
        currentRatio: currentRatio,  // *** REPLACED debt-to-equity ***
        
        // Additional context for validation
        priceToEarnings: this.safeNumber(latestRatios.priceEarningsRatio),
        quickRatio: this.safeNumber(latestRatios.quickRatio), // Backup liquidity metric
        
        // Data quality metadata
        dataTimestamp: new Date().toISOString(),
        fmpDataAge: latestGrowth.date || latestIncome.date || 'unknown',
        rawGrowthData: {
          fmpRevenueGrowth: latestGrowth.revenueGrowth,
          fmpEarningsGrowth: latestGrowth.netIncomeGrowth,
          fmpCurrentRatio: latestRatios.currentRatio,
          conversionApplied: true
        },
        
        // Production enhancement flags
        productionEnhancements: {
          currentRatioUsed: true,
          debtToEquityRemoved: true,
          projectedMetricsSkipped: true
        }
      };

      return enhancedData;

    } catch (error) {
      console.error(`‚ùå [PRODUCTION] Failed to get data for ${symbol}:`, error.message);
      return null;
    }
  }

  /**
   * *** PRODUCTION: Enhanced anomaly filtering that caps extreme outliers ***
   */
  async applyProductionQualityFiltering(rawData, stats) {
    console.log('üöÄ [PRODUCTION] Applying enhanced anomaly filtering...');
    
    const filteredData = rawData.map(company => {
      const validation = {
        qualityScore: 100, // Start with perfect score
        issues: [],
        preserved: false,
        anomaliesFiltered: [],
        productionFiltering: {
          applied: true,
          caps: {
            earningsGrowth: 500,  // Cap at 500%
            roe: 300,             // Cap at 300%
            revenueGrowth: 500,   // Cap at 500%
            fcfGrowth: 1000       // Cap at 1000% (more volatile)
          }
        }
      };
      
      // *** ENHANCED ANOMALY FILTERING ***
      let modified = false;
      
      // Cap earnings growth at 500% (removes accounting artifacts like MRK 4589%)
      if (company.earningsGrowthYoY > 500) {
        console.log(`   üö® [ANOMALY CAPPED] ${company.symbol}: Earnings growth ${company.earningsGrowthYoY}% ‚Üí 500%`);
        company.earningsGrowthYoY = 500;
        validation.anomaliesFiltered.push('earnings_growth_capped_500');
        validation.qualityScore -= 20;
        modified = true;
        stats.anomaliesFiltered++;
      }
      
      // Cap ROE at 300% (removes impossible values like 2934%)
      if (company.roe > 300) {
        console.log(`   üö® [ANOMALY CAPPED] ${company.symbol}: ROE ${company.roe}% ‚Üí 300%`);
        company.roe = 300;
        validation.anomaliesFiltered.push('roe_capped_300');
        validation.qualityScore -= 20;
        modified = true;
        stats.anomaliesFiltered++;
      }
      
      // Cap revenue growth at 500%
      if (company.revenueGrowthYoY > 500) {
        console.log(`   üö® [ANOMALY CAPPED] ${company.symbol}: Revenue growth ${company.revenueGrowthYoY}% ‚Üí 500%`);
        company.revenueGrowthYoY = 500;
        validation.anomaliesFiltered.push('revenue_growth_capped_500');
        validation.qualityScore -= 15;
        modified = true;
        stats.anomaliesFiltered++;
      }
      
      // Cap FCF growth at 1000% (more volatile, so higher cap)
      if (company.fcfGrowthYoY > 1000) {
        console.log(`   üö® [ANOMALY CAPPED] ${company.symbol}: FCF growth ${company.fcfGrowthYoY}% ‚Üí 1000%`);
        company.fcfGrowthYoY = 1000;
        validation.anomaliesFiltered.push('fcf_growth_capped_1000');
        validation.qualityScore -= 15;
        modified = true;
        stats.anomaliesFiltered++;
      }
      
      // Validate current ratio is reasonable (0.1 to 20)
      if (company.currentRatio && (company.currentRatio < 0.1 || company.currentRatio > 20)) {
        console.log(`   üö® [ANOMALY FILTERED] ${company.symbol}: Current ratio ${company.currentRatio} seems unrealistic`);
        company.currentRatio = null; // Remove unrealistic value
        validation.anomaliesFiltered.push('current_ratio_unrealistic');
        validation.qualityScore -= 10;
        modified = true;
      }
      
      // *** PRESERVE HIGH-GROWTH COMPANIES ***
      const knownGrowthCompanies = ['NVDA', 'AMD', 'TSLA', 'META', 'AMZN'];
      if (knownGrowthCompanies.includes(company.symbol)) {
        validation.preserved = true;
        validation.qualityScore = Math.max(validation.qualityScore, 80); // Minimum 80 for known growth companies
        
        if (modified) {
          console.log(`üõ°Ô∏è [PRESERVED WITH CAPS] ${company.symbol}: High-growth company with reasonable caps applied`);
        } else {
          console.log(`üõ°Ô∏è [PRESERVED CLEAN] ${company.symbol}: High-growth company with clean data`);
        }
      }
      
      return {
        ...company,
        validation
      };
    });
    
    console.log(`üöÄ [PRODUCTION] Enhanced filtering complete: ${filteredData.length} companies processed`);
    console.log(`   üìä Anomalies capped: ${stats.anomaliesFiltered}`);
    console.log(`   üõ°Ô∏è High-growth companies preserved with reasonable caps`);
    
    return filteredData;
  }

  /**
   * *** VALIDATE: Production quality validation ***
   */
  validateProductionQuality(data) {
    const knownGrowthCompanies = ['NVDA', 'AMD', 'TSLA', 'META', 'AMZN'];
    const results = {
      present: [],
      missing: [],
      criticalIssues: [],
      qualityMetrics: {
        averageQualityScore: 0,
        companiesWithCurrentRatio: 0,
        anomaliesCapped: 0
      }
    };
    
    // Calculate quality metrics
    const qualityScores = data.map(c => c.validation?.qualityScore || 100);
    results.qualityMetrics.averageQualityScore = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;
    results.qualityMetrics.companiesWithCurrentRatio = data.filter(c => c.currentRatio !== null && c.currentRatio !== undefined).length;
    results.qualityMetrics.anomaliesCapped = data.filter(c => c.validation?.anomaliesFiltered?.length > 0).length;
    
    // Validate known growth companies
    for (const symbol of knownGrowthCompanies) {
      const company = data.find(c => c.symbol === symbol);
      
      if (company) {
        results.present.push({
          symbol,
          revenueGrowth: company.revenueGrowthYoY,
          currentRatio: company.currentRatio,
          qualityScore: company.validation?.qualityScore,
          anomaliesCapped: company.validation?.anomaliesFiltered?.length || 0
        });
        
        // Validate growth rates are reasonable for known growth companies
        if (symbol === 'NVDA' && (company.revenueGrowthYoY < 50 || company.revenueGrowthYoY > 500)) {
          results.criticalIssues.push(`NVIDIA revenue growth ${company.revenueGrowthYoY}% outside expected range`);
        }
      } else {
        results.missing.push(symbol);
        results.criticalIssues.push(`${symbol} missing from final dataset`);
      }
    }
    
    // Overall quality validation
    if (results.qualityMetrics.averageQualityScore < 85) {
      results.criticalIssues.push(`Average quality score ${results.qualityMetrics.averageQualityScore.toFixed(1)}% below target 85%`);
    }
    
    if (results.qualityMetrics.companiesWithCurrentRatio < data.length * 0.8) {
      results.criticalIssues.push(`Only ${results.qualityMetrics.companiesWithCurrentRatio} companies have current ratio data`);
    }
    
    return results;
  }

  /**
   * *** UTILITY FUNCTIONS ***
   */
  async getSP500Constituents() {
    try {
      const sp500Data = await this.fmp.makeRequest('/v3/sp500_constituent', {}, 1440);
      if (sp500Data && Array.isArray(sp500Data) && sp500Data.length > 0) {
        return sp500Data;
      }
      return this.getFallbackSP500List();
    } catch (error) {
      return this.getFallbackSP500List();
    }
  }

  getFallbackSP500List() {
    return [
      { symbol: 'AAPL' }, { symbol: 'MSFT' }, { symbol: 'GOOGL' }, { symbol: 'AMZN' }, { symbol: 'NVDA' },
      { symbol: 'TSLA' }, { symbol: 'META' }, { symbol: 'BRK.B' }, { symbol: 'UNH' }, { symbol: 'JNJ' },
      { symbol: 'JPM' }, { symbol: 'V' }, { symbol: 'PG' }, { symbol: 'HD' }, { symbol: 'MA' },
      { symbol: 'AVGO' }, { symbol: 'PFE' }, { symbol: 'KO' }, { symbol: 'ABBV' }, { symbol: 'BAC' },
      { symbol: 'PEP' }, { symbol: 'TMO' }, { symbol: 'COST' }, { symbol: 'DIS' }, { symbol: 'ABT' },
      { symbol: 'WMT' }, { symbol: 'ACN' }, { symbol: 'VZ' }, { symbol: 'ADBE' }, { symbol: 'LLY' },
      { symbol: 'NKE' }, { symbol: 'MRK' }, { symbol: 'DHR' }, { symbol: 'TXN' }, { symbol: 'XOM' },
      { symbol: 'BMY' }, { symbol: 'QCOM' }, { symbol: 'ORCL' }, { symbol: 'NEE' }, { symbol: 'AMGN' },
      { symbol: 'CVX' }, { symbol: 'PM' }, { symbol: 'T' }, { symbol: 'MDT' }, { symbol: 'UNP' },
      { symbol: 'LOW' }, { symbol: 'HON' }, { symbol: 'CVS' }, { symbol: 'SCHW' }, { symbol: 'LMT' },
      { symbol: 'AMD' }, { symbol: 'CPB' } // Include both for testing
    ];
  }

  safeGrowthConversion(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    // FMP returns decimals (0.25 = 25%), multiply by 100
    return parseFloat((value * 100).toFixed(2));
  }

  safePercentageConversion(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    // FMP returns decimals (0.25 = 25%), multiply by 100
    return parseFloat((value * 100).toFixed(2));
  }

  safeNumber(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    return parseFloat(parseFloat(value).toFixed(2));
  }
}

export const fixedDataCollector = new FixedDataCollector();